<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: go, | Maia McCormick]]></title>
  <link href="http://maiamcc.github.io/blog/categories/go/atom.xml" rel="self"/>
  <link href="http://maiamcc.github.io/"/>
  <updated>2017-11-22T22:47:46-05:00</updated>
  <id>http://maiamcc.github.io/</id>
  <author>
    <name><![CDATA[Maia Remez McCormick]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What Are Interfaces?]]></title>
    <link href="http://maiamcc.github.io/blog/2017/06/17/what-are-interfaces/"/>
    <updated>2017-06-17T13:04:02-04:00</updated>
    <id>http://maiamcc.github.io/blog/2017/06/17/what-are-interfaces</id>
    <content type="html"><![CDATA[<p>This is a blog post about interfaces in Go. I wanted to write about a headscratcher that cost me several hours of work when I first started learning Go, and I figured I might as well start from the beginning and write the article on interfaces that I wish I had read back then. The story of my encounter with nil interfaces is coming soon, but for now, here&rsquo;s a brief and hopefully accessible piece on interfaces in Go.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> So, without further ado, I give you&hellip;</p>

<h3>What Is an Interface?</h3>

<p>Coming from the dynamically-typed wild west of Python, one of the bits of Go that took the most getting used to was the idea of <em>interfaces</em>. An interface is a way of typing things according to their methods. If I want a function that can take any number of different types, so long as they have a given method (or two, or five) in common, I’ll want to use an interface to accomplish this (since I can’t pass in any old thing because of Go’s type safety rules). To give a concrete example, say I’ve got these classes: <!--more--></p>

<pre><code class="go">type octopus struct {
    numTentacles int
}

func (octopus) ooze() string {
    return "ink"
}

type slug struct {
    salted bool
}

func (slug) ooze() string {
    return "slime"
}
</code></pre>

<p><code>slug</code> and <code>octopus</code> are their own types, but both have <code>ooze()</code> methods. If I wanted a function to make use of the <code>ooze</code> method, and didn’t know how to make effective use of interfaces, I might write something like this. Note that <code>interface{}</code> is a wild card and I&rsquo;ll explain why in a minute&hellip; but for now, just accept that this is the way we can allow this function to take either a slug OR an octopus (&hellip;or anything else, unfortunately) without Go complaining at us.</p>

<pre><code class="go">func oozeAttack(slugOrOctopus interface{}) string {
    switch oozingThing := slugOrOctopus.(type) {
        case slug:
            // cast oozingThing as a slug
            return fmt.Sprintf("You got %s’d!", oozingThing.ooze())
        case octopus:
            // cast oozingThing as an octopus
            return fmt.Sprintf("You got %s’d!", oozingThing.ooze())
        default:
            panic(```This thing doesn't know how to ooze!
            ...It sucks that you were able to pass this in
            without the compiler complaining at you, but
            here we are.```)
    }
}
</code></pre>

<p>Ugh. Awkward, right? And it has repeated code, and it can potentially panic b/c we have no guarantees of the type of the thing we passed, and… ugh. No good. But luckily, I can use interfaces as they were meant to be used, and suddenly my code is a lot prettier:</p>

<pre><code class="go">type oozer interface{
    // the signature of a function called "ooze",
    // which takes no args and returns a string
    ooze() string
}

func oozeAttack(o oozer) string {
    return fmt.Sprintf("You got %s’d!", o.ooze())
}
</code></pre>

<p>If an object has all of the methods required for an interface, we say that that object <em>implements</em> (or satisfies) that interface. In this case, both <code>octopus</code> and <code>slug</code> implement <code>oozer</code> because they both have <code>ooze()</code> methods. The compiler can check this for us, so we know that anything we pass into <code>oozeAttack</code> has an <code>ooze()</code> method and won’t break out code—in stark contrast to the example above, where we could pass in <em>literally anything</em> and just had to pray that it wouldn’t cause a panic.</p>

<h3>Okay, But What Is an <code>interface{}</code>?</h3>

<p>If you’ve been using Go for more than a couple of days, you’ve probably stumbled across <code>interface{}</code>, the mythical and mysterious empty interface (<a href="https://www.youtube.com/watch?v=bW7Op86ox9g">click here for dramatic effect</a>). (I even used it in the example above.) The empty interface baffled me for a long time. I understood that practically, it was a type wildcard—you used it anywhere you weren’t sure of the type of a thing. If I have a function that’s going to get passed <em>some thing</em> but I don’t know what the type of that thing is, I’ll use <code>interface{}</code> so nothing breaks:</p>

<pre><code class="go">func printMysteryObject(thing interface{}) {
        fmt.Printf("Your mystery thing is: %v", thing)
}
</code></pre>

<p>But it was only after I started thinking about what interfaces actually are, and reading some blog posts, that I figured out why this works. <code>interface{}</code> is this:</p>

<pre><code class="go">type BoringInterface interface {
        // … nothing to see here …
}
</code></pre>

<p>It’s an interface that requires no methods! And so any object at all will satisfy this interface, because any object in Go has 0+ methods. I finally understand what the flip this thing is. So exciting.</p>

<p>Stay tuned for part 2 in this series, &ldquo;When Interfaces Go Nil (dun dun dunnn)&rdquo;.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I need to make the disclaimer that lots of other folks have written about this, and the <a href="https://blog.golang.org/laws-of-reflection">Go blogpost on <em>The Laws of Reflection</em></a> probably explains this stuff better than I do. That said, I hope this blog post is more to the point, and perhaps more entertaining. (Mad props to <a href="http://aoeu.github.io/">Travis McDemus</a> for inspiration for this excellent example of how interfaces work, which I find 100% more accessible than the <code>io.Reader/Writer</code> examples that get used in all the canonical Go blogposts about interfaces.)<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
